#!/usr/bin/env perl
#
# ogma: A featureful terminal speed-reading tool using RSVP (Rapid Serial Visual Presentation) based on speedread.
#
# Show input text as a per-word RSVP (rapid serial visual presentation)
# aligned on optimal reading points.  This kind of input mode allows
# reading text at a much more rapid pace than usual as the eye can
# stay fixed on a single place.
#
# Original work (c) Petr Baudis <pasky@ucw.cz> 2014
# Original work licensed under MIT License (see LICENSE.MIT)
#
# Modifications and additions (c) Aindréas Ó hAodha <aindreas@ohaodha.ie> 2025 
# Modifications licensed under GPL v3 (see LICENSE.GPL)
#
# This combined work is distributed under GPL v3.
#
# Usage: ogma [-w WORDSPERMINUTE] [-r RESUMEPOINT] [-m] [-b] file.txt
#
# The default of 250 words per minute is very timid, designed so that
# you get used to this.  Be sure to try cranking this up, 500wpm
# should still be fairly easy to follow even for beginners.
#
# ogma can join short words together if you specify the -m switch.
# It did not work well for pasky so far, though.
#
# ogma is slightly interactive, with these controls accepted:
#
#   [ - slow down by 10%
#   ] - speed up by 10%
#   b - toggle bionic reading mode
#   m - toggle multiword mode
#   q - quit
#   space - pause (and show the last two lines)

use warnings;
use strict;
use autodie;
use v5.14;

my $wpm = 250;
my $resume = 0;
my $multiword = 0;
my $bionic = 0;

use utf8;
binmode(STDIN, ":encoding(UTF-8)");
binmode(STDOUT, ":encoding(UTF-8)");

use Term::ANSIColor;
use Term::ReadKey;
use POSIX qw(ceil floor);
use Time::HiRes qw(time sleep gettimeofday tv_interval);
use Getopt::Long;

GetOptions("wpm|w=i" => \$wpm,
       "resume|r=i" => \$resume,
       "multiword|m" => \$multiword,
       "bionic|b" => \$bionic);

my $wordtime = 0.9;
my $lentime = 0.04;
my $commatime = 2;
my $fstoptime = 3;
my $multitime = 1.2;
my $firsttime = 0.2;
my $paused = 0;
my $current_word;
my $current_orp;
my $next_word_time = 0;
my $next_input_time = 0;
my $skipped = 0;

my @lastlines;
my ($term_width, $term_height);
my $center_row;
my $center_col;

my $wordcounter = 0;
my $lettercounter = 0;
my $total_words = 0;  # Total words in document
my $t0 = [gettimeofday];

# Terminal state management
sub init_terminal {
    # Redirect stdin to /dev/tty for keyboard input
    # (file input will come from command line arg or pipe before this)
    open(my $tty, '<', '/dev/tty') or die "Cannot open /dev/tty: $!";
    *STDIN = $tty;
    
    ReadMode('cbreak');
    
    update_terminal_size();
    clear_screen();
    hide_cursor();
}

sub cleanup_terminal {
    show_cursor();
    clear_screen();
    ReadMode('restore');
}

sub update_terminal_size {
    ($term_width, $term_height) = GetTerminalSize();
    $center_row = int($term_height / 2);
    $center_col = int($term_width / 2);
}

sub clear_screen {
    print "\033[2J";  # Clear entire screen
}

sub hide_cursor {
    print "\033[?25l";
}

sub show_cursor {
    print "\033[?25h";
}

sub move_cursor {
    my ($row, $col) = @_;
    print "\033[${row};${col}H";
}

sub clear_line {
    print "\033[2K";
}

# Display functions
sub show_guide {
    move_cursor($center_row - 1, $center_col);
    print color('red') . "v" . color('reset');
}

sub show_word {
    my ($word, $i) = @_;
    
    # Clear the lines we'll use
    move_cursor($center_row, 1);
    clear_line();
    
    my $pivotch = substr($word, $i, 1);
    $pivotch = "·" if $pivotch eq ' ';
    
    # Calculate starting column so ORP is at center
    my $word_start_col = $center_col - $i;
    
    move_cursor($center_row, $word_start_col);
    
    # Display word with formatting
    print color("bold") . substr($word, 0, $i)
        . color("red") . $pivotch . color("reset")
        . ($bionic ? "" : color("bold"))
        . substr($word, $i+1)
        . color("reset");
}

sub show_progress {
    my $bottom_row = $term_height;
    
    # Bottom left: Speed and status
    move_cursor($bottom_row, 1);
    clear_line();
    print "$wpm wpm";
    
    if ($paused) {
        print "  " . color("yellow") . "PAUSED" . color("reset");
    }
    
    if ($multiword) {
        print "  " . color("cyan") . "[multi]" . color("reset");
    }
    
    if ($bionic) {
        print "  " . color("cyan") . "[bionic]" . color("reset");
    }
    
    # Bottom center: Progress bar (if we know total words)
    if ($total_words > 0) {
        my $progress_width = int($term_width * 0.4);  # 40% of screen width
        my $progress_start = int($term_width / 2) - int($progress_width / 2);
        
        my $percent = $wordcounter / $total_words;
        my $filled = int($percent * $progress_width);
        
        move_cursor($bottom_row, $progress_start);
        print color('green');
        print "█" x $filled;
        print color('dark white');
        print "░" x ($progress_width - $filled);
        print color('reset');
        
        # Show percentage
        my $pct_text = sprintf(" %d%% ", int($percent * 100));
        my $pct_col = $progress_start + $progress_width + 2;
        move_cursor($bottom_row, $pct_col);
        print $pct_text;
    }
    
    # Bottom right: Word count
    my $count_text = sprintf("Word %d", $wordcounter + $resume);
    if ($total_words > 0) {
        $count_text .= sprintf("/%d", $total_words + $resume);
    }
    move_cursor($bottom_row, $term_width - length($count_text) - 1);
    print $count_text;
}

sub print_context {
    my ($wn) = @_;
    
    # Show context lines above the word
    if ($lastlines[1]) {
        move_cursor($center_row - 3, 1);
        clear_line();
        # Truncate if too long for screen
        my $line = $lastlines[1];
        $line = substr($line, 0, $term_width - 2) if length($line) > $term_width - 2;
        print $line;
    }
    
    if ($lastlines[0]) {
        move_cursor($center_row - 2, 1);
        clear_line();
        
        my $line0 = $lastlines[0];
        $line0 = substr($line0, 0, $term_width - 2) if length($line0) > $term_width - 2;
        
        # Highlight current word in context
        $line0 =~ s/^((?:.*?(?:-|\s)+){$wn})(.*?)(-|\s)/$1 . colored($2, 'yellow') . $3/e;
        print $line0;
    }
}

# Word timing
sub find_ORP {
    my ($word) = @_;
    return 4 if (length($word) > 13);
    return (0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3)[length($word)];
}

sub word_time {
    my ($word) = @_;
    
    my $time = $wordtime;
    if ($word =~ /[.?!]\W*$/) {
        $time = $fstoptime;
    } elsif ($word =~ /[:;,]\W*$/) {
        $time = $commatime;
    } elsif ($word =~ / /) {
        $time = $multitime;
    }
    $time += sqrt(length($word)) * $lentime;
    $time *= 60 / $wpm;
    
    $time = $firsttime if ($wordcounter == 0 and $time < $firsttime);
    
    return $time;
}

# Input handling
sub process_keys {
    my ($word, $i, $wn) = @_;
    
    while (defined(my $ch = ReadKey(-1))) {  # -1 = non-blocking
        if ($ch eq '[') {
            $wpm = int($wpm * 0.9);

        } elsif ($ch eq ']') {
            $wpm = int($wpm * 1.1);

        } elsif ($ch eq 'b') {
            $bionic = not $bionic;

        } elsif ($ch eq 'm') {
            $multiword = not $multiword;

        } elsif ($ch eq ' ') {
            $paused = not $paused;
            if ($paused) {
                print_context($wn);
                show_guide();
                show_word($word, $i);
            } else {
                $next_word_time = time();
                # Clear context lines
                move_cursor($center_row - 3, 1);
                clear_line();
                move_cursor($center_row - 2, 1);
                clear_line();
            }

        } elsif ($ch eq 'q') {
            return 'quit';
        }
    }
    return '';
}

sub print_stats {
    my $elapsed = tv_interval($t0, [gettimeofday]);
    my $truewpm = $wordcounter / $elapsed * 60;

    cleanup_terminal();

    printf("\n%.2fs, %d words, %d letters, %s%.2f%s true wpm\n",
        $elapsed, $wordcounter, $lettercounter,
        color('bold green'), $truewpm, color('reset'));
}

# Signal handlers
$SIG{INT} = sub {
    print_stats();
    my $resume_word = $wordcounter + $resume;
    say " To resume from this point run with argument -r $resume_word";
    exit;
};

$SIG{WINCH} = sub {
    update_terminal_size();
    clear_screen();
};

# Count total words (for progress bar)
sub count_words {
    my @lines = @_;
    my $count = 0;
    for my $line (@lines) {
        my @words = grep { /./ } split /(?:-|\s)+/, $line;
        $count += scalar(@words);
    }
    return $count;
}

# Main loop
sub main {
    # Read all input first to count words
    my @all_lines = <>;
    chomp @all_lines;
    $total_words = count_words(@all_lines);

    # Now initialize terminal (after stdin is free)
    init_terminal();

    clear_screen();
    show_guide();
    show_progress();

    $next_word_time = time();
    $next_input_time = time();

    for my $line (@all_lines) {
        unshift @lastlines, $line;
        pop @lastlines if @lastlines > 2;

        my (@words) = grep { /./ } split /(?:-|\s)+/, $line;

        if ($multiword) {
            for (my $i = 0; $i < $#words - 1; $i++) {
                if (length($words[$i]) <= 3 and length($words[$i+1]) <= 3) {
                    $words[$i] .= ' ' . $words[$i+1];
                    splice(@words, $i+1, 1);
                }
            }
        }

        my $wn = 0;
        while (scalar(@words) > 0) {
            if ($skipped < $resume) {
                $skipped++;
                shift @words;
                next;
            }

            my $current_time = time();

            if ($next_word_time <= $current_time and !$paused) {
                $current_word = shift @words;
                $current_orp = find_ORP($current_word);
                $next_word_time += word_time($current_word);
                $wordcounter++;
                $lettercounter += length($current_word);
                $wn++;
            }

            if ($next_input_time <= $current_time) {
                my $result = process_keys($current_word, $current_orp, $wn);
                if ($result eq 'quit') {
                    print_stats();
                    return;
                }
                $next_input_time += 0.05;
            }

            show_word($current_word, $current_orp);
            show_progress();

            my $sleep_time = ($next_word_time < $next_input_time and !$paused) 
                ? $next_word_time - $current_time 
                : $next_input_time - $current_time;
            sleep($sleep_time) if ($sleep_time > 0);
        }
    }

    print_stats();
    sleep(1);
}

main();
